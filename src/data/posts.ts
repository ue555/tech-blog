import type {BlogPost} from "../types/blog";

export const blogPosts: BlogPost[] = [
  {
    id: 1,
    title: "実践Vimを読みました",
    excerpt:
      "Vimをマスターするための実践コマンド集：移動から高度な編集テクニックまで",
    content: `
## はじめに

Vimは、その独特な操作方法と急な学習曲線から敬遠されがちなテキストエディタです。しかし、一度その哲学と強力なコマンド体系を身につければ、コーディングの速度と効率は劇的に向上します。この記事では、あなたのVimスキルを次のレベルへ引き上げるための、基本的な移動から高度な編集、カスタマイズまでを網羅した実践的なコマンドを紹介します。

### 1. 基本のキーのカーソル移動を極める

Vimの効率性の根幹は、キーボードから手を離さずにテキスト内を自在に移動できることにあります。まずは、この「移動（モーション）」をマスターしましょう。

#### 単語単位の移動

単語単位の移動は、最も頻繁に使う操作の一つです。小文字と大文字のコマンドで「単語」の定義が異なる点を理解するのが重要です。

- **w**, **b**, **e**: 次/前の単語の先頭/末尾へ移動します。句読点や記号は単語の区切りと見なされます。
- **W**, **B**, **E**: 空白を基準に、次/前の単語の先頭/末尾へ移動します。hello-worldは1つの単語として扱われます。
- **ge**, **gE**: 前の単語の末尾へ移動します。**e**/**E**の後方バージョンです。

|コマンド|動作|**hello-world_test** での挙動|
|:---|:---:|---:|
|**w**|次の単語の先頭へ|**hello** → **-** → **world** → **_** → **test**|
|**W**|次のWORDの先頭へ|**hello-world_test** 全体を1単語として扱う|
|**e**|単語の末尾へ|**o** → **d** → **t**|
|**E**|WORDの末尾へ|**t** (testの末尾)|

---------

#### **行内ジャンプ**

一行が長いコードや文章では、文字単位の検索が非常に役立ちます。

- **f{char}**: 行内で前方にある **{char}** の文字へ移動します。
- **F{char}**: 行内で後方にある **{char}** の文字へ移動します。
- **t{char}**: 行内で前方にある **{char}** の手前の文字へ移動します。
- **T{char}**: 行内で後方にある **{char}** の後ろの文字へ移動します。

これらのコマンド実行後、**;** で同じ方向へ次の候補を検索し、**,** で逆方向へ検索できます。これはデバッグで特定の関数呼び出しを次々に確認する際などに非常に便利です。

---------

#### **論理行 vs 表示行**

エディタで長い行が折り返されて表示されている場合、Vimはそれを「表示行」と、実際の改行コードが入っている行を「論理行」として区別します。

- **論理行**での移動: **j**, **k**, **^**(行頭の非空白文字へ), **$**(行末へ)
- **表示行**での移動: **gj**, **gk**, **g^**, **g$**

デフォルトの **j** **k** の挙動を **gj** **gk** に変更する、以下のマッピングは非常に人気があります。

\`\`\`sh: VimScript
nnoremap k gk
nnoremap j gj
\`\`\`

### 2. テキスト編集の効率を爆上げする

Vimの編集は「オペレータ + モーション」という文法で成り立っています。これにより、驚くほど直感的に複雑な編集が可能です。

#### **オペレータとテキストオブジェクト**

- オペレータ: d (削除), c (変更), y (ヤンク/コピー) など。
- テキストオブジェクト: 操作対象の範囲を指定します。

テキストオブジェクトの例:
|オブジェクト|意味|使用例|
|:---|:---:|---:|
|**iw**|内側の単語 (inner word)|**diw**: 現在のカーソル位置の単語を削除|
|**aw**|単語と空白 (a word)|**daw**: 単語とそれに続く空白を削除|
|**i"**, **a"**|ダブルクォートの内側/全体|**ci"**: "で囲まれた範囲を変更|
|**it**, **at**|タグの内側/全体|**yit**: HTML/XMLタグの中身をヤンク|
|**ip**, **ap**|段落の内側/全体|**dap**: 空行を含む段落全体を削除|

例えば、**ci"** は「Change Inner **"**（ダブルクォートの内側を変更する）」と読めます。カーソルが **"この部分"** のどこかにあれば、このコマンド一発でクォート内のテキストが削除され、挿入モードに移行します。

---------

#### **究極のコマンド「.」(ドット)**

**.** コマンドは、直前に行った変更（挿入、削除、置換）を繰り返します。これはVimの中でも最も強力なコマンドの一つです。
**dw** で単語を削除した後、別の単語の上で **.** を押せば、その単語も削除されます。複数の箇所に同じ変更を加えたい場合に絶大な効果を発揮します。

---------

#### **大文字/小文字の変換**

gU, gu, g~ オペレータとモーション/テキストオブジェクトを組み合わせることで、範囲指定して大文字/小文字変換ができます。

- **gUaw**: 現在の単語を大文字に (**gU** + **aw**)
- **gUit**: タグの内側を大文字に (**gU** + **it**)
- **gUU** または **gugu**: 行全体を大文字/小文字に

---------

### 3. 検索と置換 - プロフェッショナルの技

テキストの検索と置換は、開発において避けては通れない作業です。Vimはこれを強力にサポートします。

#### **賢い検索設定**

**.vimrc** に以下を設定しておくと、検索が非常に快適になります。
\`\`\`sh: VimScript
set ignorecase " 検索時に大文字/小文字を区別しない
set smartcase  " 検索パターンに大文字が含まれている場合のみ、大文字/小文字を区別する
\`\`\`

これにより、通常は小文字で検索すれば "foo", "Foo", "FOO" の全てにマッチし、"Foo" と入力すれば "Foo" にのみマッチするようになります。

---------

#### **正規表現を味方につける**

Vimの正規表現は強力ですが、特殊文字のエスケープが少し面倒です。パターンの先頭に \\v (very magic) を付けることで、ほとんどの記号が特殊文字として扱われ、より直感的に記述できます。

例: 重複した単語を検索する
\`\`\`sh: VimScript
/\\v<(\\w+)\\_s+\\1>
\`\`\`

- **\\v**: very magicモード
- **<**: 単語の先頭
- **(\\w+)**: 1つ以上の単語文字をキャプチャ
- **\\_s+**: 空白または改行
- **\\1**: 最初にキャプチャした単語と一致
- **>**: 単語の末尾

---------

#### **マッチ範囲の精密制御** **\\zs, **\\ze**

**\\zs** (start) と **\\ze** (end) を使うと、パターンのどの部分を実際にマッチとしてハイライト・置換するかを制御できます。

例: **function(arg)** の **function** のみマッチさせたい
\`\`\`sh: VimScript
/\\v\\w+\\ze(
\`\`\`

これは **(** が続く単語にマッチしますが、実際にマッチするのは ( の手前まで (\\ze) です。

---------

#### **強力なグローバルコマンド** **:g**

**:g/{pattern}/[cmd]** は、**{pattern}** にマッチする全ての行で **[cmd]** を実行する非常に強力なコマンドです。

例: **{...}** ブロック内の行をソートする
\`\`\`sh: VimScript
:g/{/ .+1,/}/-1 sort
\`\`\`

これは **{** のある行の次の行から、**}** のある行の前の行までを範囲として **sort** コマンドを実行します。

---------

### 4. 作業空間を最適化する - ウィンドウとタブ

Vimでは、複数のファイルを同時に開いて効率的に作業するためのウィンドウとタブ機能が充実しています。コマンドは **<C-w>** (Ctrl + w) から始まります。

**<C-w>s** / **<C-w>v:** ウィンドウを水平/垂直に分割
**<C-w>h,j,k,l**: 左/下/上/右のウィンドウへ移動
**<C-w>c**: 現在のウィンドウを閉じる
**<C-w>o**: 現在のウィンドウ以外を全て閉じる
**gt** / **gT**: 次/前のタブへ移動
**<C-w>T**: 現在のウィンドウを新しいタブへ移動

---------

## まとめ

今回紹介したコマンドは、Vimの持つ膨大な機能のほんの一部に過ぎません。しかし、これらの基本的な「文法」をマスターするだけで、あなたのテキスト編集は間違いなく別次元の体験になるはずです。

Vimの道は一日にしてならず。日々のコーディングの中で少しずつ新しいコマンドを試し、手に馴染ませていくことが上達への一番の近道です。快適なVimライフをお楽しみください！
`,
    date: "2025-08-08",
    tags: ["読書", "vim"],
    imageUrl:
      "images/blog1.png",
  },
  {
    id: 2,
    title: "脱・カオスなGitログ！Conventional Commits入門で共同開発をスムーズに",
    excerpt:
      "脱・カオスなGitログ！Conventional Commits入門で共同開発をスムーズに",
    content: `
「このコミット、何のためにやったんだっけ…？」「リリースノートを作るのが大変…」

チーム開発でGitを使っていると、コミットログが分かりにくく、後から追いかけるのが困難になることはありませんか？そんな悩みを解決するのが、今回紹介する Conventional Commits というコミットメッセージの規約です。

この規約を導入するだけで、コミット履歴の可読性が劇的に向上し、変更履歴（CHANGELOG）の自動生成や、セマンティックバージョニングの自動化も可能になります。

### Conventional Commitsの基本構造

ルールは非常にシンプルです。コミットメッセージを以下の形式で記述します。

\`\`\`bash
<type>(<scope>): <subject>
[optional body]
[optional footer]
\`\`\`

- **type**: コミットの種類（feat, fix など）。**必須** です。
- **scope**: コミットが影響する範囲（例: auth, ui）。**任意** です。
- **subject**: コミット内容の簡潔な説明。**必須** です。

---------

### 主要なコミット種別（Type）

**type** には、以下のような種類が定義されています。プロジェクトでよく使われるものから覚えていきましょう。

|Type|説明|使用例|
|:---|:---:|---:|
|**feat**|新機能の追加|feat: ユーザーのプロフィール編集機能を追加|
|**fix**|バグ修正|fix: モバイル版でのレイアウト崩れを修正|
|**style**|バグ修正や機能追加ではないコードの改善|refactor: 認証ロジックをサービスクラスに分離|
|**refactor**|バグ修正や機能追加ではないコードの改善|refactor: 認証ロジックをサービスクラスに分離|
|**perf**|パフォーマンスを向上させるコードの変更|perf: 画像読み込みを遅延させることで表示を高速化|
|**test**|テストの追加・修正|test: ログイン機能のテストケースを追加|
|**chore**|ビルドシステムや外部依存に関する変更|build: webpackの設定を本番用に最適化|
|**ci**|CI/CD関連の設定ファイルの変更|ci: GitHub Actionsのデプロイワークフローを修正|
|**revert**|過去のコミットを取り消す変更|revert: コミット abc1234 を取り消し|

特に **feat** と **fix**、そして雑多なタスクを扱う **chore** は非常によく使われます。

---------

### より明確に伝えるための追加ルール

#### **スコープ（Scope）で変更範囲を示す**

変更箇所をより具体的にするために、**( )** でスコープを追加できます。これにより、どの部分の変更なのかが一目で分かります。

\`\`\`bash
# 認証(auth)機能に関するバグ修正
git commit -m "fix(auth): パスワードリセット機能のバグを修正"

# UIコンポーネントに関する新機能
git commit -m "feat(ui): 新しいボタンコンポーネントを追加"

# 依存ライブラリ(deps)に関する更新
git commit -m "chore(deps): React を v18 に更新"
\`\`\`

#### **破壊的変更（Breaking Change）を明記する**

APIの仕様変更やデータベーススキーマの変更など、互換性のない変更（破壊的変更）を行う場合は、その旨を明記する必要があります。

#### 方法1: **type** の直後に **!** を付ける

最もシンプルで分かりやすい方法です。
\`\`\`bash
git commit -m "feat!: 認証APIをOAuth2ベースに大幅変更"
\`\`\`

#### **方法2: フッターに BREAKING CHANGE: を記述する**

変更内容の詳細を記述したい場合に適しています。

\`\`\`bash
git commit -m "feat: 新しい認証システムを導入

BREAKING CHANGE: この変更により、既存のAPIトークンはすべて無効になります。
新しいトークンを再発行する必要があります。"
\`\`\`

この **BREAKING CHANGE** があるコミットは、メジャーバージョンの更新（例: v1.2.3 → v2.0.0）のトリガーとなります。

---------
### なぜConventional Commitsを導入するべきか？

- ✅ **可読性の向上**: 誰が見ても変更の意図がすぐに理解でき、履歴を追いやすくなります。
- ✅ **CHANGELOGの自動生成**: **fix** や **feat** といったコミットから、ツールを使って自動でリリースノートを作成できます。
- ✅ **セマンティックバージョニングの自動化**: **fix** はパッチバージョン、**feat** はマイナーバージョン、**BREAKING CHANGE** はメジャーバージョンの更新に機械的につなげられます。
- ✅ **円滑なレビュー**: レビュアーはコミットの種別を見るだけで、変更の目的を素早く把握できます。

## まとめ

Conventional Commitsは、チーム開発におけるコミュニケーションを円滑にし、リリース作業を自動化するためのシンプルで強力な規約です。最初は少し面倒に感じるかもしれませんが、チーム全体で取り組むことで、その恩恵は計り知れません。

ぜひ、次のプロジェクトから導入を検討してみてはいかがでしょうか？

#### **参考元**

- [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/)
- [Conventional Commits(日本語訳)](https://www.conventionalcommits.org/ja/v1.0.0/)
`,
    date: "2025-08-09",
    tags: ["Git"],
    imageUrl:
      "images/blog2.png",
  },
];
